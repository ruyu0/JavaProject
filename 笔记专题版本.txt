专题一、数字和字符串

1.1 装箱和拆箱 
封装类：所有的基本类型，都有对应的类类型，比如int对应的类是Integer ，这种类就叫做封装类
Number类：数字封装类有，Byte,Short,Integer,Long,Float,Double ，这些类都是抽象类Number的子类
基本类型转封装类、封装类转基本类型（见程序Test）
自动装箱：不需要调用构造方法，通过=符号自动把 基本类型 转换为 类类型 就叫装箱
自动拆箱：不需要调用Integer的intValue方法，通过=就自动转换成int类型，就叫拆箱
int的最大值可以通过其对应的封装类Integer.MAX_VALUE获取

1.2 字符串转换
数字转字符串：方法一：使用String类的静态方法valueOf  方法二：先把基本类型装箱为对象，然后调用对象的toString
字符串转数字：调用Integer的静态方法parseInt

1.3数学方法：java.lang.Math提供了一些常用的数学运算方法，并且都是以静态方法的形式存在
四舍五入round、开方、随机数、次方、自然常数、Π

1.4格式化输出（见程序Test）
如果不使用格式化输出，就需要进行字符串连接，如果变量比较多，拼接就会显得繁琐
使用格式化输出，就可以简洁明了
%s 表示字符串
%d 表示数字
%n 表示换行
printf和format能够达到一模一样的效果，如何通过eclipse查看java源代码 可以看到，在printf中直接调用了format
换行符：换行符就是另起一行 --- '\n' 换行（newline）
	回车符就是回到一行的开头 --- '\r' 回车（return）
	在eclipse里敲一个回车，实际上是回车换行符
	Java是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如Windows,Linux,Mac
	然而在不同的操作系统，换行符是不一样的
	（1）在DOS和Windows中，每行结尾是 “\r\n”；
	（2）Linux系统里，每行结尾只有 “\n”；
	（3）Mac系统里，每行结尾是只有 "\r"。
	为了使得同一个java程序的换行符在所有的操作系统中都有一样的表现，使用%n，就可以做到平台无关的换行（都可以用）
总长度、左对齐、补0、千分位分隔符、小数点位数、本地化表达（见程序Test）

1.5字符
Character常见方法：isLetter(), isDigit(), isWhitespace(), isUpperCase(), isLowerCase(), toUpperCase(), toLowerCase(), toString()
常见转义：（见程序Test）'\\'用来输出字符'\'

1.6字符串
String是final的
immutable 是指不可改变的，比如创建了一个字符串对象String garen ="盖伦";
不可改变的具体含义是指：不能增加长度；不能减少长度；不能插入字符；不能删除字符；不能修改字符
一旦创建好这个字符串，里面的内容 永远 不能改变
String 的表现就像是一个常量

1.7对字符串的操作
charAt, toCharArray, subString, split, trim, toLowerCase, toUpperCase, indexOf, lashIndexOf, contains, replaceAll, replaceFirst

1.8比较字符串
判断字符串内容相同：不能用==，用equals，equalsIgnoreCase
startWith，endsWith

1.9 StringBuffer
是可变长的字符串
方法：append delete insert reverse length capacity
比较String 和 StringBuffer的性能（见程序Test）
测试MyStringBuffer性能（见程序Test）
10:47 2020/12/28


专题二 日期和日历
2.1（java.util.Date）
创建Data对象：Date()和Date(long mils)
 getTime() 得到一个long型的整数，这个整数代表 从1970.1.1 08:00:00:000 开始 每经历一毫秒，增加1
System.currentTimeMillis()：当前日期的毫秒数
new Date().getTime() 和 System.currentTimeMillis() 是一样的不过由于机器性能的原因，可能会相差几十毫秒，毕竟每执行一行代码，都是需要时间的
2.2 SimpleDateFormat 日期格式化类
日期转字符串（见程序Test）：format方法，y代表年, M代表月份，d代表，H代表24小时制的时，h代表12小时制的时，m代表分，s代表秒，S代表毫秒
字符串转日期（见程序Test）：parse方法，需要异常处理
2.3日历类Calendar（采用单例模式获取日历对象Calendar.getInstance();）
Calendar与Date进行转换：getTime方法；setTime方法
翻日历：add方法，在原日期上增加年/月/日；set方法，直接设置年/月/日（见程序Test）

专题三 异常处理
3.1 异常定义： 导致程序的正常流程被中断的事件，叫做异常
3.2 
多异常处理（见程序Test）：1、分别进行catch 2、放在一个catch里统一捕捉 ：从 JDK7开始支持，好处是捕捉的代码更紧凑，不足之处是，一旦发生异常，不能确定到底是哪种异常，需要通过instanceof 进行判断具体的异常类型
finally：无论是否出现异常，finally中的代码都会被执行
throws： 处理办法也是两种，要么是try catch处理掉，要么也是抛出去。
3.3 异常分类
异常分类： 可查异常，运行时异常和错误3种 ，其中，运行时异常和错误又叫非可查异常
可查异常： CheckedException
可查异常即必须进行处理的异常，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException，如果不处理，编译器，就不让你通过
运行时异常RuntimeException指： 不是必须进行try catch的异常 
常见运行时异常: 除数不能为0异常:ArithmeticException ；下标越界异常:ArrayIndexOutOfBoundsException ；空指针异常:NullPointerException 
在编写代码的时候，依然可以使用try catch throws进行处理，与可查异常不同之处在于，即便不进行try catch，也不会有编译错误 
Java之所以会设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常太过于普遍，如果都需要进行捕捉，代码的可读性就会变得很糟糕。
错误Error，指的是系统级别的异常，通常是内存用光了，在默认设置下，一般java程序启动的时候，最大可以使用16m的内存
如例不停的给StringBuffer追加字符，很快就把内存使用光了。抛出OutOfMemoryError，与运行时异常一样，错误也是不要求强制捕捉的
有：AWTError、VirtualMachineError(StackOverflowError\OutOfMemoryError)
3.4 Throwable类
Exception和Error都继承了该类，所以在捕捉的时候，也可以使用Throwable进行捕捉
3.5自定义异常类（见程序Test）

10:19 2021/1/29
专题四 IO
4.1 文件和文件夹对象File 使用相对路径和绝对路径创建
4.1.1 方法：exists	isDirectory	isFile	length	lastModified（见Test）setLastModified（见Test）	renameTo()（见Test）
	list()和listFile()	getParent()和getParentFile()	mkdir和mkdirs	createNewFile()和getParentFile().mkdir（见文件Test）	listRoots	delete和deleteOnExit
4.2 流就是一系列数据
输入流： InputStream，Reader(unicode编码双字节字符)
FileInputStream	FilterInputStream	SequenceInputStream	ByteArrayInputStream	StringBufferInputStream	PipedInputStream
CharArrayReader	BufferedReader(LineNumberReader)	FilterReader	InputStreamReader(FileReader)		StringReader
FilterInputStream:	BufferedInputStream	PushbackInputSteam	LineNumberInputStream	DateInputStream(ObjectInputStream)	
输出流：OutputStream，Writer
FileOutputSteam	FilterOutputSteam		无		ByteArrayOutputStream		无		PipedOutputStream
CharArrayWriter	BufferedWriter(无）			FilterWriter	OutputStreamWriter(FileWriter)		StringWriter	PrintWriter
FilterOutputStream:	BufferedOutputStream	无			无			DateOutputStream(ObjectOutputStream)		PrintStream
4.3 字节流的读取和写入、含中文文件（见程序Test)
4.4 关闭流的方法：
	在try中关闭：如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 不推荐使用；
	在finally关闭：标准的严谨的关闭流的方式；
	使用try()的方式；
4.5 字符流的读取的写入、含中文文件（见程序Test)
23:32 2021/2/4
4.6 常见编码 ISO-8859-1 ASCII 数字和西欧字母；GBK GB2312 BIG5 中文；UNICODE (统一码，万国码)
20:08 2021/2/5
4.7 缓存流读写（见程序Test）
4.8 数据流 要用DataInputStream 读取一个文件，这个文件必须是由DataOutputStream 写出的，否则会出现EOFException；
	因为DataOutputStream 在写出的时候会做一些特殊标记，只有DataInputStream 才能成功的读取。
	使用数据流的writeUTF()和readUTF() 可以进行数据的格式化顺序读写
4.9 对象流 一个对象以流的形式进行传输，叫做序列化。 该对象所对应的类，必须是实现Serializable接口
	字节流的正确读写中文（见4.3）、字符流的正确读取中文（见test程序）
	默认编码：Charset.defaultCharset()
4.10 System.out 是常用的在控制台输出数据的 
System.in 可以从控制台输入数据：使用System.in.read虽然可以读取数据，但是很不方便，使用Scanner就可以逐行读取了
4.11 解决EOFException
	在存入对象的时候使用集合的方式来存储对象,这样在获取时就只需要获取集合,然后遍历集合即可，这种是将本来的多个对象转化为一个集合对象,再从集合对象中去获取数据；
	在存入对象前或者后面加一个标志,可以在第一位置加一个int类型的值来记录存入的对象个数,也可以在最后加入一个null来做结束标识；
	使用异常处理方式
	
21:37 2021/2/6
专题五 集合框架 （java集合分为Collection和Map两种体系）
5.1 ArrayList 实现了List接口
5.1.1 数组的局限性：容量限定；ArrayList容器的容量"capacity"会随着对象的增加，自动增长 
5.1.2 常用方法
	add	contains	get	indexof	remove	set(用于替换指定位置的元素)	size	addAll	clear
	数组和ArrayList的转换，toArray(见test):如果要转换为一个Hero数组，那么需要传递一个Hero数组类型的对象给toArray()，这样toArray方法才知道，你希望转换为哪种类型的数组，否则只能转换为Object数组
	asList接受的参数是T .... t，泛型不能是基本类型，不能用基本类型的数组转list，会识别成数组的list。用基本类型的对象类。
	返回的对象是Arrays的内部类，对list的操作仍然反映在原数组上，因此这个list是定长的，不支持add、remove操作；

https://blog.csdn.net/zty1317313805/article/details/82771034
5.1.3 遍历
	用for循环；用增强型for（无下标，无法初始化）；用iterator（见程序Test）
5.2 其他集合
5.2.1 LinkedList 
实现了List接口外，LinkedList还实现了双向链表结构Deque：addLast, addFirst, getLast, getFirst, removeLast, removeFirst
实现了Queue接口：offer, poll, peek
5.2.2 Stack : push, pop
5.2.3 二叉树：三个遍历，层序遍历
16:49 2021/3/7
5.2.4 HashMap<key, value>
健不能重复，值可以重复，键重复会覆盖
比较查找内容的性能（ArrayList vs HashMap)(见程序Test）
get和containsKey有区别
5.2.5 HashSet<T>
Set中的元素，不能重复,既不是按照插入顺序，也不是按照hashcode的顺序， 不同jvm版本顺序不同
 * It makes no guarantees as to the iteration order of the set; 
 * in particular, it does not guarantee that the order will remain constant over time. 
HashSet自身并没有独立的实现，而是在里面封装了一个Map，HashSet作为Map的key，而所有value是一个名为PRESENT的static的Object对象
解决大量重复数据中有几种数据的问题（见Test)
5.2.6 Collection
是一个接口，子接口有List，Deque，Queue，Set
5.2.7 Collections是一个类，容器的工具类,就如同Arrays是数组的工具类（见Test）
reverse
shuffle 混淆List中数据的顺序
sort 对List中的数据进行排序
swap 交换两个数据的位置
rotate 把List中的数据，向右滚动指定单位的长度
synchronizedList 把非线程安全的List转换为线程安全的List（未完成）
5.3.1 比较ArrayList和HashSet
ArrayList: 有顺序，HashSet: 无顺序
List中的数据可以重复，Set中的数据不能够重复
重复判断标准是:
首先看hashcode是否相同
如果hashcode不同，则认为是不同数据
如果hashcode相同，再比较equals，如果equals相同，则是相同数据，否则是不同数据
5.3.2 ArrayList和LinkedList比较
ArrayList 插入，删除数据慢，LinkedList， 插入，删除数据快（见Test）
ArrayList是顺序结构，所以定位很快，指哪找哪。LinkedList 是链表结构，定位慢，必须得一个一个的数过去
5.3.3 HashMap和HashTable比较
继承：HashTable继承自Dirctionary，HashMap继承自AbstractMap，二者均实现了Map接口；
线程安全性：HashTable的方法是同步的，即线程安全的。HaspMap的方法不是同步的，线程安全的。在多线程并发的情况下，可直接使用HashTable；要使用HashMap，就需要对HashMap的同步处理（见Test，未完成）
键值：HashTable中不允许有null键和null值，HashMap中允许出现一个null键，可以存在一个或者多个键的值都为null。
	程序中，对于HashMap，如果使用get(参数为 键)方法时，返回结果为null，可能是该键不存在，也可能是该键对应的值为null，这就出现了结果的二义性。
	因此，在HashMap中，使用get()方法来查询键对应的值，应该先使用containskey()方法判断是否存在该键。（见程序Test）
遍历：这两个在遍历方式的实现不同。HashTable和HashMap两者都实现了Iterator。但是，由于历史原因，HashTable还使用了Enumeration。
哈希值：HashTable是直接使用对象的hashCode。HashMap是重新计算hash值。
扩容：HashTable和HashMap的底层实现的数组和初始大小和扩容方式。HashTable初始大小为11，并且每次扩容都为：2*old+1。HashMap的默认大小为16，并且一 定是2的指数，每次扩容都为old*2。
5.3.4 集合中的几种set（比较顺序不同，见Test）
HashSet：哈希表结构，底层由HashMap实现，无特定顺序，不同版本虚拟机的顺序不同
LinkedListSet：按照插入顺序
TreeSet：也是基于Map来实现，具体实现TreeMap，其底层结构为红黑树（特殊的二叉查找树）
	具有排序功能，分为自然排序(123456)和自定义排序两类，默认是自然排序
5.4.1 集合框架hashcode原理
HashMap查找比List查找快，原因：每个非基本类型对象都要对应的hashcode，查找时就不用一个一个比较相同，先找到对应的hashcode，再找值
（见Test）自定义字符串的hashcode：
	如下是Java API提供的String的hashcode生成办法；
	hash=s[0]∗31^(n−1) +s[1]∗31 ^(n−2)+...+s[n−1]=(...(s[0]∗31+s[1])∗31+s[2])∗31+...)+s[n−1]
	s[0] 表示第一位字符
	n表示字符串的长度
(见Test)自定义HashMap
（见Test）比较HashMap和ArrayList的性能
5.4.2 比较器（见Test）
5.4.3 聚合操作 （未完成）
JDK8之后，引入了对集合的聚合操作，可以非常容易的遍历，筛选，比较集合中的元素。
0:46 2021/4/4


