专题一、数字和字符串

1.1 装箱和拆箱 
封装类：所有的基本类型，都有对应的类类型，比如int对应的类是Integer ，这种类就叫做封装类
Number类：数字封装类有，Byte,Short,Integer,Long,Float,Double ，这些类都是抽象类Number的子类
基本类型转封装类、封装类转基本类型（见程序Test）
自动装箱：不需要调用构造方法，通过=符号自动把 基本类型 转换为 类类型 就叫装箱
自动拆箱：不需要调用Integer的intValue方法，通过=就自动转换成int类型，就叫拆箱
int的最大值可以通过其对应的封装类Integer.MAX_VALUE获取

1.2 字符串转换
数字转字符串：方法一：使用String类的静态方法valueOf  方法二：先把基本类型装箱为对象，然后调用对象的toString
字符串转数字：调用Integer的静态方法parseInt

1.3数学方法：java.lang.Math提供了一些常用的数学运算方法，并且都是以静态方法的形式存在
四舍五入round、开方、随机数、次方、自然常数、Π

1.4格式化输出（见程序Test）
如果不使用格式化输出，就需要进行字符串连接，如果变量比较多，拼接就会显得繁琐
使用格式化输出，就可以简洁明了
%s 表示字符串
%d 表示数字
%n 表示换行
printf和format能够达到一模一样的效果，如何通过eclipse查看java源代码 可以看到，在printf中直接调用了format
换行符：换行符就是另起一行 --- '\n' 换行（newline）
	回车符就是回到一行的开头 --- '\r' 回车（return）
	在eclipse里敲一个回车，实际上是回车换行符
	Java是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如Windows,Linux,Mac
	然而在不同的操作系统，换行符是不一样的
	（1）在DOS和Windows中，每行结尾是 “\r\n”；
	（2）Linux系统里，每行结尾只有 “\n”；
	（3）Mac系统里，每行结尾是只有 "\r"。
	为了使得同一个java程序的换行符在所有的操作系统中都有一样的表现，使用%n，就可以做到平台无关的换行（都可以用）
总长度、左对齐、补0、千分位分隔符、小数点位数、本地化表达（见程序Test）

1.5字符
Character常见方法：isLetter(), isDigit(), isWhitespace(), isUpperCase(), isLowerCase(), toUpperCase(), toLowerCase(), toString()
常见转义：（见程序Test）'\\'用来输出字符'\'

1.6字符串
String是final的
immutable 是指不可改变的，比如创建了一个字符串对象String garen ="盖伦";
不可改变的具体含义是指：不能增加长度；不能减少长度；不能插入字符；不能删除字符；不能修改字符
一旦创建好这个字符串，里面的内容 永远 不能改变
String 的表现就像是一个常量

1.7对字符串的操作
charAt, toCharArray, subString, split, trim, toLowerCase, toUpperCase, indexOf, lashIndexOf, contains, replaceAll, replaceFirst

1.8比较字符串
判断字符串内容相同：不能用==，用equals，equalsIgnoreCase
startWith，endsWith

1.9 StringBuffer
是可变长的字符串
方法：append delete insert reverse length capacity
比较String 和 StringBuffer的性能（见程序Test）
测试MyStringBuffer性能（见程序Test）
10:47 2020/12/28


专题二 日期和日历
2.1（java.util.Date）
创建Data对象：Date()和Date(long mils)
 getTime() 得到一个long型的整数，这个整数代表 从1970.1.1 08:00:00:000 开始 每经历一毫秒，增加1
System.currentTimeMillis()：当前日期的毫秒数
new Date().getTime() 和 System.currentTimeMillis() 是一样的不过由于机器性能的原因，可能会相差几十毫秒，毕竟每执行一行代码，都是需要时间的
2.2 SimpleDateFormat 日期格式化类
日期转字符串（见程序Test）：format方法，y代表年, M代表月份，d代表，H代表24小时制的时，h代表12小时制的时，m代表分，s代表秒，S代表毫秒
字符串转日期（见程序Test）：parse方法，需要异常处理
2.3日历类Calendar（采用单例模式获取日历对象Calendar.getInstance();）
Calendar与Date进行转换：getTime方法；setTime方法
翻日历：add方法，在原日期上增加年/月/日；set方法，直接设置年/月/日（见程序Test）

专题三 异常处理
1.1 异常定义： 导致程序的正常流程被中断的事件，叫做异常
1.2 
多异常处理（见程序Test）：1、分别进行catch 2、放在一个catch里统一捕捉 ：从 JDK7开始支持，好处是捕捉的代码更紧凑，不足之处是，一旦发生异常，不能确定到底是哪种异常，需要通过instanceof 进行判断具体的异常类型
finally：无论是否出现异常，finally中的代码都会被执行
throws： 处理办法也是两种，要么是try catch处理掉，要么也是抛出去。
1.3 异常分类
异常分类： 可查异常，运行时异常和错误3种 ，其中，运行时异常和错误又叫非可查异常
可查异常： CheckedException
可查异常即必须进行处理的异常，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException，如果不处理，编译器，就不让你通过
运行时异常RuntimeException指： 不是必须进行try catch的异常 
常见运行时异常: 除数不能为0异常:ArithmeticException ；下标越界异常:ArrayIndexOutOfBoundsException ；空指针异常:NullPointerException 
在编写代码的时候，依然可以使用try catch throws进行处理，与可查异常不同之处在于，即便不进行try catch，也不会有编译错误 
Java之所以会设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常太过于普遍，如果都需要进行捕捉，代码的可读性就会变得很糟糕。
错误Error，指的是系统级别的异常，通常是内存用光了，在默认设置下，一般java程序启动的时候，最大可以使用16m的内存
如例不停的给StringBuffer追加字符，很快就把内存使用光了。抛出OutOfMemoryError，与运行时异常一样，错误也是不要求强制捕捉的
有：AWTError、VirtualMachineError(StackOverflowError\OutOfMemoryError)
1.4 Throwable类
Exception和Error都继承了该类，所以在捕捉的时候，也可以使用Throwable进行捕捉
1.5自定义异常类（见程序Test）