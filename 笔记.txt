一、饿汉式是立即加载的方式，无论是否会用到这个对象，都会加载。
如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。

懒汉式，是延迟加载的方式，只有使用的时候才会加载。 并且有线程安全的考量(鉴于同学们学习的进度，暂时不对线程的章节做展开)。
使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。

看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式

见程序TestGiantDragonLazySingleton和TestGiantDragon
这个是面试的时候经常会考的点，面试题通常的问法是:
什么是单例模式？
回答的时候，要答到三元素
1. 构造方法私有化
2. 静态属性指向实例
3. public static的 getInstance方法，返回第二步的静态属性

17:36 2020/12/22用单例模式写水龙 见程序TestWaterDragon

17:50 2020/12/22
二、静态变量和成员变量有默认值：基本数据类型：int = 0, long = 0, double = 0.0, float = 0.0, boolean = false, char = 0; 对象数据类型：默认值都为null
局部变量没有默认值，需要初始化；
数值new操作有默认值

三、枚举的好处：限定取值范围

四、接口 （见程序ADHero、APHero、ADAPHero）

五、引用类型和对象类型之间的类型转换(见程序Test）
子类向父类直接转换（向上转型）
父类向子类转换（向下转型）看情况，父类指向的类型如果刚好是子类的类型则可以，不同则可能发生类型转换异常ClassCastException
实现类向接口转型（向上）直接
接口转实现类（向下）看情况

17:35 2020/12/24
六、instanceof Hero 判断一个引用所指向的对象，是否是Hero类型，或者Hero的子类实例

七、多态（见程序）
变量的声明类型都是同一个类型，调用同一个方法，却能呈现不同的状态（子类重写了父类的方法）
条件：1. 父类（接口）引用指向子类对象 	2. 调用的方法有重写
不使用多态的话，同一个方法需要分别命名设计
！！！类静态方法不支持多态，根据声明类型进行调用，不可以抽象。

八、super
1、子类构造方法会默认首先执行super()来调用父类的无参构造方法，如果父类没有无参构造方法，则必须显式调用父类的构造方法
2、通过super来调用父类的属性和方法

九、finalize方法：内存不足时触发垃圾回收，可以重写，但是有java虚拟机调用
Object类的equals方法等价于==，可以重写成深比较
Object类还提供线程同步相关方法wait、notify、notifyAll。

十、final关键字
修饰类：该类为最终类，不可被继承
修饰方法：该方法不能在子类中重写
修饰基本类型变量：只有一次赋值
修饰非基本类型（引用）：只能1次指向对象
常量指的是可以公开，直接访问，不会变化的值

十一、抽象类
不提供抽象方法的前提下，声明为抽象类 
一旦一个类被声明为抽象类，就不能够被直接实例化

抽象类和接口的区别
区别1：
子类只能继承一个抽象类，不能继承多个
子类可以实现多个接口
区别2：
抽象类可以定义
public,protected,package,private
静态和非静态属性
final和非final属性
但是接口中声明的属性，只能是
public
静态
final的
即便没有显式的声明

注: 抽象类和接口都可以有实例方法。 接口中的实例方法，叫做默认方法


十二、内部类：https://www.cnblogs.com/dolphin0520/p/3811445.html
在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类
非静态内部类（成员内部类）：定义在另一个类内部（程序Test）；
	成员内部类必须有对应外部类实例才能创建和初始化；
	成员内部类可以访问外部类的所有成员
局部内部类（本地类）：局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。
	局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的
静态内部类：定义在另一个类内部用static修饰的类
	静态内部类是不需要依赖于外部类实例的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法
匿名内部类：在声明一个类的同时实例化它，使代码更加简洁精练
	为了快速使用，直接实例化一个抽象类或接口，并“当场”实现其抽象方法
	匿名内部类在编译的时候由系统自动起名为（外部类名$1.class）

十三、默认方法（https://www.cnblogs.com/sum-41/p/10878807.html）
默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法（default关键字）
随着默认方法在Java8中的引入，有可能出现一个类继承了多个签名一样的方法。为解决这种多继承关系，Java8提供了下面三条规则：
1、类中的方法优先级最高，类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。
2、如果第一条无法判断，那么子接口的优先级更高：方法签名相同时，优先选择拥有最具体实现的默认方法的接口， 即如果B继承了A，那么B就比A更加具体。
3、最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法， 显式地选择使用哪一个默认方法的实现。